<?php

if (!function_exists('global_hook_test_callback')) {
	function global_hook_test_callback() {
		HookTest::$callbackCalled = true;
	}
}

/**
 * Test class for Hook.
 * Generated by PHPUnit on 2013-02-28 at 19:19:52.
 */
class HookTest extends PHPUnit_Framework_TestCase {

	static $callbackCalled = false;

	/**
	 * This method is called before a test is executed.
	 */
	protected function setUp() {
		Hook::remove();
	}

	/**
	 * This method is called after a test is executed.
	 */
	protected function tearDown() {
		self::$callbackCalled = false;
		Hook::remove();
	}

	static function staticCallback() {
		HookTest::$callbackCalled = true;
	}

	function instanceCallback() {
		HookTest::$callbackCalled = true;
	}

	/**
	 * @covers Hook::add
	 * @covers Hook::call
	 */
	public function testSupportsDifferentCallbackTypes() {
		$callbacks = array(
			function() {
				HookTest::$callbackCalled = true;
			},
			array('HookTest', 'staticCallback'),
			array($this, 'instanceCallback'),
			'global_hook_test_callback'
		);

		foreach ($callbacks as $index => $callback) {
			$this->tearDown();
			Hook::add('my_hook', $callback);
			Hook::call('my_hook');
			$this->assertTrue(self::$callbackCalled, 'Callback ' . $index . ' should have been called.');
		}
	}

	/**
	 * @covers Hook::call
	 */
	public function testCallbackCanReturnFalse() {
		$callbacks = array(
			function() {
				HookTest::$callbackCalled = true;
			},
			array('HookTest', 'staticCallback'),
			array($this, 'instanceCallback'),
			'global_hook_test_callback'
		);

		foreach ($callbacks as $callback) {
			Hook::add('my_hook', $callback, 100);
		}
		Hook::add('my_hook', function(){
			return false;
		}, 99);
		Hook::call('my_hook');
		$this->assertFalse(self::$callbackCalled, 'Returning false should have prevented the execution of the other hooks.');
	}

	/**
	 * @covers Hook::add
	 */
	public function testGet() {
		Hook::add('my_hook', 'my_callback', 100);

		// all hooks
		$this->assertNotEmpty(Hook::get());

		// same hook, different priority
		$this->assertEmpty(Hook::get('my_hook', 50));

		// same priority, different hook
		$this->assertEmpty(Hook::get('some_other_hook', 100));

		// diffent hook, no priority distinction
		$this->assertEmpty(Hook::get('some_other_hook'));

		$callbacks = Hook::get('my_hook');
		$this->assertNotEmpty($callbacks);
		$this->assertEquals('my_callback', $callbacks[0]);
	}

	/**
	 * @covers Hook::getCallbackHash
	 */
	public function testGetCallbackHash() {
		$callbacks = array(
			function() {
				HookTest::$callbackCalled = true;
			},
			array('HookTest', 'staticCallback'),
			array($this, 'instanceCallback'),
			'global_hook_test_callback'
		);

		$ids = array();

		// make sure it always returns the same thing for a given input
		foreach ($callbacks as $callback) {
			$ids[] = $id = Hook::getCallbackHash($callback);
			$this->assertEquals($id, Hook::getCallbackHash($callback), 'getCallbackHash should always return the same value for the same callback.');
		}
		$this->assertEquals(count($ids), count(array_unique($ids)), 'getCallbackHash should return unique values for unique callbacks.');
	}

	/**
	 * @covers Hook::remove
	 */
	public function testRemove() {
		$callbacks = array(
			function() {
				HookTest::$callbackCalled = true;
			},
			array('HookTest', 'staticCallback'),
			array($this, 'instanceCallback'),
			'global_hook_test_callback'
		);
		foreach ($callbacks as $key => $callback) {
			Hook::add('my_callback', $callback);
			$this->assertEquals(1, count(Hook::get('my_callback')), '1 callback was added, so 1 callback should be in array.');
			Hook::remove('my_callback', $callback);
			$this->assertEquals(0, count(Hook::get('my_callback')), '1 callback was removed, so 0 callbacks should be in array.');
		}
	}

}